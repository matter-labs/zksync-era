# WitnessGenerator

Please read this
[doc](https://www.notion.so/matterlabs/Draft-FRI-Prover-Integration-Prover-Shadowing-c4b1373786eb43779a93118be4be5d99)
for rationale of this binary, alongside the existing one in zk-core.

The component is responsible for generating prover jobs and saving artifacts needed for the next round of proof
aggregation. That is, every aggregation round needs two sets of input:

- computed proofs from the previous round
- some artifacts that the witness generator of previous round(s) returns. There are four rounds of proofs for every
  block, each of them starts with an invocation of `{Round}WitnessGenerator` with a corresponding
  `WitnessGeneratorJobType`:

## BasicCircuitsWitnessGenerator

- generates basic circuits (circuits like `Main VM` - up to 50 \* 48 = 2400 circuits):
- input table: `basic_circuit_witness_jobs` (TODO SMA-1362: will be renamed from `witness_inputs`)
- artifact/output table: `leaf_aggregation_jobs` (also creates job stubs in `node_aggregation_jobs` and
  `scheduler_aggregation_jobs`) value in `aggregation_round` field of `prover_jobs` table: 0

## LeafAggregationWitnessGenerator

- generates leaf aggregation circuits (up to 48 circuits of type `LeafAggregation`)
- input table: `leaf_aggregation_jobs`
- artifact/output table: `node_aggregation_jobs`
- value in `aggregation_round` field of `prover_jobs` table: 1

## NodeAggregationWitnessGenerator

- generates one circuit of type `NodeAggregation`
- input table: `leaf_aggregation_jobs`
- value in `aggregation_round` field of `prover_jobs` table: 2

## SchedulerWitnessGenerator

- generates one circuit of type `Scheduler`
- input table: `scheduler_witness_jobs`
- value in `aggregation_round` field of `prover_jobs` table: 3

One round of prover generation consists of:

- `WitnessGenerator` picks up the next `queued` job in its input table and processes it (invoking the corresponding
  helper function in `zkevm_test_harness` repo)
- it saves the generated circuits to `prover_jobs` table and the other artifacts to its output table
- the individual proofs are picked up by the provers, processed, and marked as complete.
- when the last proof for this round is computed, the prover updates the row in the output table setting its status to
  `queued`
- `WitnessGenerator` picks up such job and proceeds to the next round

Note that the very first input table (`witness_inputs`) is populated by the tree (as the input artifact for the
`WitnessGeneratorJobType::BasicCircuits` is the merkle proofs)

## Running BWG for custom batch

After releases `prover-v15.1.0` and `core-v24.9.0` basic witness generator doesn't need access to core database anymore.
Database information now lives in input file, called `witness_inputs_<batch>.bin`
generated by different core components).

First of all, you need to have a `witness_inputs` file for a batch you want run BWG for. You can get it from your GCS
bucket or ask someone to provide it for you. To get the file from bucket, run

```shell
gsutil cp gs://your_bucket/witness_inputs/witness_inputs_<batch>.bin <path/to/era/prover/artifacts/witness_inputs>
```

Note, that you need to have `gsutil` installed, and you need to have access to the bucket.

Now, database needs to know about the batch and the protocol version it should use. Check the latest protocol version in
the codebase by checking const `PROVER_PROTOCOL_SEMANTIC_VERSION` or run the binary in `prover` workspace:

```console
cargo run --bin prover_version
```

It will give you the latest prover protocol version in a semver format, like `0.24.2`, you need to know only minor and
patch versions. Now, go to the `prover/crates/bin/vk_setup_data_generator_server_fri/data/commitments.json` and get
`snark_wrapper` value from it. Then, you need to insert the info about protocol version into the database. First,
connect to the database, e.g. locally you can do it like that:

```shell
psql postgres://postgres:notsecurepassword@localhost/prover_local
```

And run the following query:

```shell
INSERT INTO
prover_fri_protocol_versions (
id,
recursion_scheduler_level_vk_hash,
created_at,
protocol_version_patch
)
VALUES
(<minor version>, '<snark wrapper value>'::bytea, NOW(), <patch version>)
ON CONFLICT (id, protocol_version_patch) DO NOTHING

```

Now, you need to insert the batch into the database. Run the following query:

```shell
INSERT INTO
witness_inputs_fri (
l1_batch_number,
witness_inputs_blob_url,
protocol_version,
status,
created_at,
updated_at,
protocol_version_patch
)
VALUES
(<batch number>, 'witness_inputs_<batch_number>.bin', <minor version>, 'queued', NOW(), NOW(), <patch version>)
ON CONFLICT (l1_batch_number) DO NOTHING
```

Finally, run the basic witness generator itself:

```shell
API_PROMETHEUS_LISTENER_PORT=3116 zk f cargo run --release --bin zksync_witness_generator -- --round=basic_circuits
```

And you are good to go!

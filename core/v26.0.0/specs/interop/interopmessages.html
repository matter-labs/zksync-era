<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Interop Messages - ZKsync Era Documentation</title>


        <!-- Custom HTML head -->
        <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../css/version-box.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZKsync Era Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-era/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-era/tree/main/docs/src/specs/interop/interopmessages.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="interop-messages"><a class="header" href="#interop-messages">Interop Messages</a></h1>
<p>In this section, we’re going to cover the lowest level of the interop stack: <strong>Interop Messages</strong> — the interface that
forms the foundation for everything else.</p>
<p>We’ll explore the details of the interface, its use cases, and how it compares to similar interfaces from
Superchain/Optimism.</p>
<p>This is an advanced document. While most users and app developers typically interact with higher levels of interop, it’s
still valuable to understand how the internals work.</p>
<h2 id="basics"><a class="header" href="#basics">Basics</a></h2>
<p><img src="../img/interopmsg.png" alt="interopmsg.png" /></p>
<p>Interop Messages are the lowest level of our stack.</p>
<p>An <strong>InteropMessage</strong> contains data and offers two methods:</p>
<ul>
<li>Send a message</li>
<li>Verify that a given message was sent on some chain</li>
</ul>
<p>Notice that the message itself doesn’t have any ‘destination chain’ or address—it is simply a payload that a user (or
contract) is creating. Think of it as a broadcast.</p>
<p>The <code>InteropCenter</code> is a contract that is pre-deployed on all chains at a fixed address <code>0x00..1234</code>.</p>
<pre><code class="language-solidity">contract InteropCenter {
  // Sends interop message. Can be called by anyone.
  // Returns the unique interopHash.
 function sendInteropMessage(bytes data) returns interopHash;

  // Interop message - uniquely identified by the hash of the payload.
 struct InteropMessage {
   bytes data;
   address sender; // filled by InteropCenter
   uint256 sourceChainId; // filled by InteropCenter
   uint256 messageNum; // a 'nonce' to guarantee different hashes.
 }

 // Verifies if such interop message was ever producted.
 function verifyInteropMessage(bytes32 interopHash, Proof merkleProof) return bool;
}
</code></pre>
<p>When you call <code>sendInteropMessage</code>, the <code>InteropCenter</code> adds additional fields, such as your sender address, source
chain ID, and messageNum (a nonce ensuring the hash of this structure is globally unique). It then returns the
<code>interopHash</code>.</p>
<p>This <code>interopHash</code> serves as a globally unique identifier that can be used on any chain in the network to call
<code>verifyInteropMessage</code>.</p>
<p><img src="../img/verifyinteropmsg.png" alt="A message created on one chain can be verified on any other chain." /></p>
<h4 id="how-do-i-get-the-proof"><a class="header" href="#how-do-i-get-the-proof">How do I get the proof</a></h4>
<p>You’ll notice that <strong>verifyInteropMessage</strong> has a second argument — a proof that you need to provide. This proof is a
Merkle tree proof (more details below). You can obtain it by querying the
<a href="https://docs.zksync.io/build/api-reference/zks-rpc#zks_getl2tol1msgproof">chain</a> , or generate it off-chain - by
looking at the chain’s state on L1</p>
<h4 id="how-does-the-interop-message-differ-from-other-layers-interoptransactions-interopcalls"><a class="header" href="#how-does-the-interop-message-differ-from-other-layers-interoptransactions-interopcalls">How does the interop message differ from other layers (InteropTransactions, InteropCalls)</a></h4>
<p>As the most basic layer, an interop message doesn’t include any advanced features — it lacks support for selecting
destination chains, nullifiers/replay, cancellation, and more.</p>
<p>If you need these capabilities, consider integrating with a higher layer of interop, such as Call or Bundle, which
provide these additional functionalities.</p>
<h2 id="simple-use-case"><a class="header" href="#simple-use-case">Simple Use Case</a></h2>
<p>Before we dive into the details of how the system works, let’s look at a simple use case for a DApp that decides to use
InteropMessage.</p>
<p>For this example, imagine a basic cross-chain contract where the <code>signup()</code> method can be called on chains B, C, and D
only if someone has first called <code>signup_open()</code> on chain A.</p>
<pre><code class="language-solidity">// Contract deployed on chain A.
contract SignupManager {
  public bytes32 sigup_open_msg_hash;
  function signup_open() onlyOwner {
    // We are open for business
    signup_open_msg_hash = InteropCenter(INTEROP_CENTER_ADDRESS).sendInteropMessage("We are open");
  }
}

// Contract deployed on all other chains.
contract SignupContract {
  public bool signupIsOpen;
  // Anyone can call it.
  function openSignup(InteropMessage message, InteropProof proof) {
    InteropCenter(INTEROP_CENTER_ADDRESS).verifyInteropMessage(keccak(message), proof);
    require(message.sourceChainId == CHAIN_A_ID);
    require(message.sender == SIGNUP_MANAGER_ON_CHAIN_A);
    require(message.data == "We are open");
   signupIsOpen = true;
  }

  function signup() {
     require(signupIsOpen);
     signedUpUser[msg.sender] = true;
  }
}
</code></pre>
<p>In the example above, the <code>signupManager</code> on chain A calls the <code>signup_open</code> method. After that, any user on other
chains can retrieve the <code>signup_open_msg_hash</code>, obtain the necessary proof from the Gateway (or another source), and
call the <code>openSignup</code> function on any destination chain.</p>
<h2 id="deeper-technical-dive"><a class="header" href="#deeper-technical-dive">Deeper Technical Dive</a></h2>
<p>Let’s break down what happens inside the InteropCenter when a new interop message is created:</p>
<pre><code class="language-solidity">function sendInteropMessage(bytes data) {
  messageNum += 1;
  msg = InteropMessage({data, msg.sender, block.chain_id, messageNum});
  // Does L2-&gt;L1 Messaging.
  sendToL1(abi.encode(msg));
  return keccak(msg);
}
</code></pre>
<p>As you can see, it populates the necessary data and then calls the <code>sendToL1</code> method.</p>
<p>The <code>sendToL1</code> method is part of a system contract that gathers all messages during a batch, constructs a Merkle tree
from them at the end of the batch, and sends this tree to the SettlementLayer (Gateway) when the batch is committed.</p>
<p><img src="../img/sendtol1.png" alt="sendtol1.png" /></p>
<p>The settlement layer receives the messages and once the proof for the batch is submitted (or more accurately, during the
“execute” step), it will add the root of the Merkle tree to its <code>messageRoot</code> (sometimes called <code>globalRoot</code>).</p>
<p><img src="../img/globalroot.png" alt="globalroot.png" /></p>
<p>The <code>messageRoot</code> is the root of the Merkle tree that includes all messages from all chains. Each chain regularly reads
the messageRoot value from the Gateway to stay synchronized.</p>
<p><img src="../img/gateway.png" alt="gateway.png" /></p>
<p>If a user wants to call <code>verifyInteropMessage</code> on a chain, they first need to query the Gateway for the Merkle path from
the batch they are interested in up to the <code>messageRoot</code>. Once they have this path, they can provide it as an argument
when calling a method on the destination chain (such as the <code>openSignup</code> method in our example).</p>
<p><img src="../img/proofmerklepath.png" alt="proofmerklepath.png" /></p>
<h4 id="what-if-chain-doesnt-provide-the-proof"><a class="header" href="#what-if-chain-doesnt-provide-the-proof">What if Chain doesn’t provide the proof</a></h4>
<p>If the chain doesn’t respond, users can manually re-create the Merkle proof using data available on L1. Every
interopMessage is also sent to L1.</p>
<h4 id="message-roots-change-frequently"><a class="header" href="#message-roots-change-frequently">Message roots change frequently</a></h4>
<p>Yes, message roots update continuously as new chains prove their blocks. However, chains retain historical message roots
for a reasonable period (around 24 hours) to ensure that recently generated Merkle paths remain valid.</p>
<h4 id="is-this-secure-could-a-chain-operator-like-chain-d-use-a-different-message-root"><a class="header" href="#is-this-secure-could-a-chain-operator-like-chain-d-use-a-different-message-root">Is this secure? Could a chain operator, like Chain D, use a different message root</a></h4>
<p>Yes, it’s secure. If a malicious operator on Chain D attempted to use a different message root, they wouldn’t be able to
submit the proof for their new batch to the Gateway. This is because the proof’s public inputs must include the valid
message root.</p>
<h3 id="other-features"><a class="header" href="#other-features">Other Features</a></h3>
<h4 id="dependency-set"><a class="header" href="#dependency-set">Dependency Set</a></h4>
<ul>
<li>In ElasticChain, this is implicitly handled by the Gateway. Any chain that is part of the message root can exchange
messages with any other chain, effectively forming an undirected graph.</li>
</ul>
<h4 id="timestamps-and-expiration"><a class="header" href="#timestamps-and-expiration">Timestamps and Expiration</a></h4>
<ul>
<li>In ElasticChain, older messages become increasingly difficult to validate as it becomes harder to gather the data
required to construct a Merkle proof. Expiration is also being considered for this reason, but the specifics are yet
to be determined.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../specs/interop/overview.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../specs/interop/bundlesandcalls.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../specs/interop/overview.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../specs/interop/bundlesandcalls.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../js/version-box.js"></script>
        <script src="../../js/mermaid-init.js"></script>


    </div>
    </body>
</html>

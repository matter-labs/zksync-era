use anyhow::Context as _;
use zksync_concurrency::{ctx, error::Wrap as _, scope, time};
use zksync_config::configs::consensus::{ConsensusConfig, ConsensusSecrets};
use zksync_consensus_executor::{self as executor, attestation};
use zksync_consensus_roles::validator;
use zksync_consensus_storage::{BatchStore, BlockStore};
use std::sync::Arc;

use crate::{
    config,
    storage::{ConnectionPool, Store},
};

/// Task running a consensus validator for the main node.
/// Main node is currently the only leader of the consensus - i.e. it proposes all the
/// L2 blocks (generated by `Statekeeper`).
pub async fn run_main_node(
    ctx: &ctx::Ctx,
    cfg: ConsensusConfig,
    secrets: ConsensusSecrets,
    pool: ConnectionPool,
) -> anyhow::Result<()> {
    let validator_key = config::validator_key(&secrets)
        .context("validator_key")?
        .context("missing validator_key")?;

    let attester = config::attester_key(&secrets)
        .context("attester_key")?;

    tracing::debug!(is_attester = attester.is_some(), "main node attester mode");

    scope::run!(&ctx, |ctx, s| async {
        if let Some(spec) = &cfg.genesis_spec {
            let spec = config::GenesisSpec::parse(spec).context("GenesisSpec::parse()")?;

            pool.connection(ctx)
                .await
                .wrap("connection()")?
                .adjust_genesis(ctx, &spec)
                .await
                .wrap("adjust_genesis()")?;
        }

        // The main node doesn't have a payload queue as it produces all the L2 blocks itself.
        let (store, runner) = Store::new(ctx, pool.clone(), None).await.wrap("Store::new()")?;
        s.spawn_bg(runner.run(ctx));

        let (block_store, runner) = BlockStore::new(ctx, Box::new(store.clone()))
            .await
            .wrap("BlockStore::new()")?;
        s.spawn_bg(runner.run(ctx));

        anyhow::ensure!(
             block_store.genesis().leader_selection
                == validator::LeaderSelectionMode::Sticky(validator_key.public()),
            "unsupported leader selection mode - main node has to be the leader"
        );

        let (batch_store, runner) = BatchStore::new(ctx, Box::new(store.clone()))
            .await
            .wrap("BatchStore::new()")?;
        s.spawn_bg(runner.run(ctx));

        let attestation = Arc::new(attestation::Controller::new(attester)); 
        s.spawn_bg(run_attestation_updater(ctx,&pool,attestation.clone()));

        let executor = executor::Executor {
            config: config::executor(&cfg, &secrets)?,
            block_store,
            batch_store,
            validator: Some(executor::Validator {
                key: validator_key,
                replica_store: Box::new(store.clone()),
                payload_manager: Box::new(store.clone()),
            }),
            attestation,
        };

        tracing::info!("running the main node executor");
        executor.run(ctx).await
    })
    .await
}

async fn run_attestation_updater(
    ctx :&ctx::Ctx,
    pool: &ConnectionPool,
    attestation: Arc<attestation::Controller>,
) -> anyhow::Result<()> {
    const POLL_INTERVAL: time::Duration = time::Duration::seconds(1);
    // TODO
    Ok(())
}

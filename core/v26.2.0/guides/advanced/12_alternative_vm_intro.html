<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>EraVM intro - ZKsync Era Documentation</title>


        <!-- Custom HTML head -->
        <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../css/version-box.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZKsync Era Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-era/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-era/tree/main/docs/src/guides/advanced/12_alternative_vm_intro.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="zkevm-internals"><a class="header" href="#zkevm-internals">zkEVM internals</a></h1>
<h2 id="zkevm-clarifier"><a class="header" href="#zkevm-clarifier">zkEVM clarifier</a></h2>
<p>The ZKsync zkEVM plays a fundamentally different role in the zkStack than the EVM does in Ethereum. The EVM is used to
execute code in Ethereum’s state transition function. This STF needs a client to implement and run it. Ethereum has a
multi-client philosophy, there are multiple clients, and they are written in Go, Rust, and other traditional programming
languages, all running and verifying the same STF.</p>
<p>We have a different set of requirements, we need to produce a proof that some client executed the STF correctly. The
first consequence is that the client needs to be hard-coded, we cannot have the same multi-client philosophy. This
client is the zkEVM, it can run the STF efficiently, including execution of smart contracts similarly to the EVM. The
zkEVM was also designed to be proven efficiently.</p>
<p>For efficiency reasons it the zkEVM is similar to the EVM. This makes executing smart programs inside of it easy. It
also has special features that are not in the EVM but are needed for the rollup’s STF, storage, gas metering,
precompiles and other things. Some of these features are implemented as system contracts while others are built into the
VM. System Contracts are contracts with special permissions, deployed at predefined addresses. Finally, we have the
bootloader, which is also a contract, although it is not deployed at any address. This is the STF that is ultimately
executed by the zkEVM, and executes the transaction against the state.</p>
<!-- kl to do *Add different abstraction levels diagram here:*-->
<p>Full specification of the zkEVM is beyond the scope of this document. However, this section will give you most of the
details needed for understanding the L2 system smart contracts &amp; basic differences between EVM and zkEVM. Note also that
usually understanding the EVM is needed for efficient smart contract development. Understanding the zkEVM goes beyond
this, it is needed for developing the rollup itself.</p>
<h2 id="registers-and-memory-management"><a class="header" href="#registers-and-memory-management">Registers and memory management</a></h2>
<p>On EVM, during transaction execution, the following memory areas are available:</p>
<ul>
<li><code>memory</code> itself.</li>
<li><code>calldata</code> the immutable slice of parent memory.</li>
<li><code>returndata</code> the immutable slice returned by the latest call to another contract.</li>
<li><code>stack</code> where the local variables are stored.</li>
</ul>
<p>Unlike EVM, which is stack machine, zkEVM has 16 registers. Instead of receiving input from <code>calldata</code>, zkEVM starts by
receiving a <em>pointer</em> in its first register <em>(<em>basically a packed struct with 4 elements: the memory page id, start and
length of the slice to which it points to</em>)</em> to the calldata page of the parent. Similarly, a transaction can receive
some other additional data within its registers at the start of the program: whether the transaction should invoke the
constructor
<a href="https://github.com/matter-labs/zksync-era/blob/main/docs/specs/zk_evm/system_contracts.md#contractdeployer--immutablesimulator">more about deployments here</a>,
whether the transaction has <code>isSystem</code> flag, etc. The meaning of each of these flags will be expanded further in this
section.</p>
<p><em>Pointers</em> are separate type in the VM. It is only possible to:</p>
<ul>
<li>Read some value within a pointer.</li>
<li>Shrink the pointer by reducing the slice to which pointer points to.</li>
<li>Receive the pointer to the <code>returndata</code> as a calldata.</li>
<li>Pointers can be stored only on stack/registers to make sure that the other contracts can not read <code>memory/returndata</code>
of contracts they are not supposed to.</li>
<li>A pointer can be converted to the u256 integer representing it, but an integer can not be converted to a pointer to
prevent unallowed memory access.</li>
<li>It is not possible to return a pointer that points to a memory page with id smaller than the one for the current page.
What this means is that it is only possible to <code>return</code> only pointer to the memory of the current frame or one of the
pointers returned by the subcalls of the current frame.</li>
</ul>
<h3 id="memory-areas-in-zkevm"><a class="header" href="#memory-areas-in-zkevm">Memory areas in zkEVM</a></h3>
<p>For each frame, the following memory areas are allocated:</p>
<ul>
<li><em>Heap</em> (plays the same role as <code>memory</code> on Ethereum).</li>
<li><em>AuxHeap</em> (auxiliary heap). It has the same properties as Heap, but it is used for the compiler to encode
calldata/copy the <code>returndata</code> from the calls to system contracts to not interfere with the standard Solidity memory
alignment.</li>
<li><em>Stack</em>. Unlike Ethereum, stack is not the primary place to get arguments for opcodes. The biggest difference between
stack on zkEVM and EVM is that on ZKsync stack can be accessed at any location (just like memory). While users do not
pay for the growth of stack, the stack can be fully cleared at the end of the frame, so the overhead is minimal.</li>
<li><em>Code</em>. The memory area from which the VM executes the code of the contract. The contract itself can not read the code
page, it is only done implicitly by the VM.</li>
</ul>
<p>Also, as mentioned in the previous section, the contract receives the pointer to the calldata.</p>
<h3 id="managing-returndata--calldata"><a class="header" href="#managing-returndata--calldata">Managing returndata &amp; calldata</a></h3>
<p>Whenever a contract finishes its execution, the parent’s frame receives a <em>pointer</em> as <code>returndata</code>. This pointer may
point to the child frame’s Heap/AuxHeap or it can even be the same <code>returndata</code> pointer that the child frame received
from some of its child frames.</p>
<p>The same goes with the <code>calldata</code>. Whenever a contract starts its execution, it receives the pointer to the calldata.
The parent frame can provide any valid pointer as the calldata, which means it can either be a pointer to the slice of
parent’s frame memory (heap or auxHeap) or it can be some valid pointer that the parent frame has received before as
calldata/returndata.</p>
<p>Contracts simply remember the calldata pointer at the start of the execution frame (it is by design of the compiler) and
remembers the latest received returndata pointer.</p>
<p>Some important implications of this is that it is now possible to do the following calls without any memory copying:</p>
<p>A → B → C</p>
<p>where C receives a slice of the calldata received by B.</p>
<p>The same goes for returning data:</p>
<p>A ← B ← C</p>
<p>There is no need to copy returned data if the B returns a slice of the returndata returned by C.</p>
<p>Note, that you can <em>not</em> use the pointer that you received via calldata as returndata (i.e. return it at the end of the
execution frame). Otherwise, it would be possible that returndata points to the memory slice of the active frame and
allow editing the <code>returndata</code>. It means that in the examples above, C could not return a slice of its calldata without
memory copying.</p>
<p>Some of these memory optimizations can be seen utilized in the
<a href="https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/libraries/EfficientCall.sol">EfficientCall</a>
library that allows to perform a call while reusing the slice of calldata that the frame already has, without memory
copying.</p>
<h3 id="returndata--precompiles"><a class="header" href="#returndata--precompiles">Returndata &amp; precompiles</a></h3>
<p>Some of the operations which are opcodes on Ethereum, have become calls to some of the system contracts. The most
notable examples are <code>Keccak256</code>, <code>SystemContext</code>, etc. Note, that, if done naively, the following lines of code would
work differently on ZKsync and Ethereum:</p>
<pre><code class="language-solidity">pop(call(...))
keccak(...)
returndatacopy(...)
</code></pre>
<p>Since the call to keccak precompile would modify the <code>returndata</code>. To avoid this, our compiler does not override the
latest <code>returndata</code> pointer after calls to such opcode-like precompiles.</p>
<h2 id="zkevm-specific-opcodes"><a class="header" href="#zkevm-specific-opcodes">zkEVM specific opcodes</a></h2>
<p>While some Ethereum opcodes are not supported out of the box, some of the new opcodes were added to facilitate the
development of the system contracts.</p>
<p>Note, that this lists does not aim to be specific about the internals, but rather explain methods in the
<a href="https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractHelper.sol">SystemContractHelper.sol</a></p>
<h3 id="only-for-kernel-space"><a class="header" href="#only-for-kernel-space"><strong>Only for kernel space</strong></a></h3>
<p>These opcodes are allowed only for contracts in kernel space (i.e. system contracts). If executed in other places they
result in <code>revert(0,0)</code>.</p>
<ul>
<li><code>mimic_call</code>. The same as a normal <code>call</code>, but it can alter the <code>msg.sender</code> field of the transaction.</li>
<li><code>to_l1</code>. Sends a system L2→L1 log to Ethereum. The structure of this log can be seen
<a href="https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/contracts/ethereum/contracts/zksync/Storage.sol#L47">here</a>.</li>
<li><code>event</code>. Emits an L2 log to ZKsync. Note, that L2 logs are not equivalent to Ethereum events. Each L2 log can emit 64
bytes of data (the actual size is 88 bytes, because it includes the emitter address, etc). A single Ethereum event is
represented with multiple <code>event</code> logs constitute. This opcode is only used by <code>EventWriter</code> system contract.</li>
<li><code>precompile_call</code>. This is an opcode that accepts two parameters: the uint256 representing the packed parameters for
it as well as the ergs to burn. Besides the price for the precompile call itself, it burns the provided ergs and
executes the precompile. The action that it does depend on <code>this</code> during execution:
<ul>
<li>If it is the address of the <code>ecrecover</code> system contract, it performs the ecrecover operation</li>
<li>If it is the address of the <code>sha256</code>/<code>keccak256</code> system contracts, it performs the corresponding hashing operation.</li>
<li>It does nothing (i.e. just burns ergs) otherwise. It can be used to burn ergs needed for L2→L1 communication or
publication of bytecodes onchain.</li>
</ul>
</li>
<li><code>setValueForNextFarCall</code> sets <code>msg.value</code> for the next <code>call</code>/<code>mimic_call</code>. Note, that it does not mean that the value
will be really transferred. It just sets the corresponding <code>msg.value</code> context variable. The transferring of ETH
should be done via other means by the system contract that uses this parameter. Note, that this method has no effect
on <code>delegatecall</code> , since <code>delegatecall</code> inherits the <code>msg.value</code> of the previous frame.</li>
<li><code>increment_tx_counter</code> increments the counter of the transactions within the VM. The transaction counter used mostly
for the VM’s internal tracking of events. Used only in bootloader after the end of each transaction.</li>
</ul>
<p>Note, that currently we do not have access to the <code>tx_counter</code> within VM (i.e. for now it is possible to increment it
and it will be automatically used for logs such as <code>event</code>s as well as system logs produced by <code>to_l1</code>, but we can not
read it). We need to read it to publish the <em>user</em> L2→L1 logs, so <code>increment_tx_counter</code> is always accompanied by the
corresponding call to the
<a href="https://github.com/matter-labs/zksync-era/blob/main/docs/specs/zk_evm/system_contracts.md#systemcontext">SystemContext</a>
contract.</p>
<p>More on the difference between system and user logs can be read
<a href="https://github.com/code-423n4/2023-10-zksync/blob/main/docs/Smart%20contract%20Section/Handling%20pubdata%20in%20Boojum.md">here</a>. -
<code>set_pubdata_price</code> sets the price (in gas) for publishing a single byte of pubdata.</p>
<h3 id="generally-accessible"><a class="header" href="#generally-accessible"><strong>Generally accessible</strong></a></h3>
<p>Here are opcodes that can be generally accessed by any contract. Note that while the VM allows to access these methods,
it does not mean that this is easy: the compiler might not have convenient support for some use-cases yet.</p>
<ul>
<li><code>near_call</code>. It is basically a “framed” jump to some location of the code of your contract. The difference between the
<code>near_call</code> and ordinary jump are:
<ol>
<li>It is possible to provide an ergsLimit for it. Note, that unlike “<code>far_call</code>”s (i.e. calls between contracts) the
63/64 rule does not apply to them.</li>
<li>If the near call frame panics, all state changes made by it are reversed. Please note, that the memory changes will
<strong>not</strong> be reverted.</li>
</ol>
</li>
<li><code>getMeta</code>. Returns an u256 packed value of
<a href="https://github.com/code-423n4/2023-10-zksync/blob/ef99273a8fdb19f5912ca38ba46d6bd02071363d/code/system-contracts/contracts/libraries/SystemContractHelper.sol#L42">ZkSyncMeta</a>
struct. Note that this is not tight packing. The struct is formed by the
<a href="https://github.com/matter-labs/era-zkevm_opcode_defs/blob/c7ab62f4c60b27dfc690c3ab3efb5fff1ded1a25/src/definitions/abi/meta.rs#L4">following rust code</a>.</li>
<li><code>getCodeAddress</code> — receives the address of the executed code. This is different from <code>this</code> , since in case of
delegatecalls <code>this</code> is preserved, but <code>codeAddress</code> is not.</li>
</ul>
<h3 id="flags-for-calls"><a class="header" href="#flags-for-calls">Flags for calls</a></h3>
<p>Besides the calldata, it is also possible to provide additional information to the callee when doing <code>call</code> ,
<code>mimic_call</code>, <code>delegate_call</code>. The called contract will receive the following information in its first 12 registers at
the start of execution:</p>
<ul>
<li><em>r1</em> — the pointer to the calldata.</li>
<li><em>r2</em> — the pointer with flags of the call. This is a mask, where each bit is set only if certain flags have been set
to the call. Currently, two flags are supported: 0-th bit: <code>isConstructor</code> flag. This flag can only be set by system
contracts and denotes whether the account should execute its constructor logic. Note, unlike Ethereum, there is no
separation on constructor &amp; deployment bytecode. More on that can be read
<a href="https://github.com/matter-labs/zksync-era/blob/main/docs/specs/zk_evm/system_contracts.md#contractdeployer--immutablesimulator">here</a>.
1-st bit: <code>isSystem</code> flag. Whether the call intends a system contracts’ function. While most of the system contracts’
functions are relatively harmless, accessing some with calldata only may break the invariants of Ethereum, e.g. if the
system contract uses <code>mimic_call</code>: no one expects that by calling a contract some operations may be done out of the
name of the caller. This flag can be only set if the callee is in kernel space.</li>
<li>The rest r3..r12 registers are non-empty only if the <code>isSystem</code> flag is set. There may be arbitrary values passed,
which we call <code>extraAbiParams</code>.</li>
</ul>
<p>The compiler implementation is that these flags are remembered by the contract and can be accessed later during
execution via special
<a href="https://github.com/code-423n4/2023-10-zksync/blob/main/docs/VM%20Section/How%20compiler%20works/instructions/extensions/overview.md">simulations</a>.</p>
<p>If the caller provides inappropriate flags (i.e. tries to set <code>isSystem</code> flag when callee is not in the kernel space),
the flags are ignored.</p>
<h3 id="onlysystemcall-modifier"><a class="header" href="#onlysystemcall-modifier"><code>onlySystemCall</code> modifier</a></h3>
<p>Some of the system contracts can act on behalf of the user or have a very important impact on the behavior of the
account. That’s why we wanted to make it clear that users can not invoke potentially dangerous operations by doing a
simple EVM-like <code>call</code>. Whenever a user wants to invoke some of the operations which we considered dangerous, they must
provide “<code>isSystem</code>” flag with them.</p>
<p>The <code>onlySystemCall</code> flag checks that the call was either done with the “isSystemCall” flag provided or the call is done
by another system contract (since Matter Labs is fully aware of system contracts).</p>
<h3 id="simulations-via-our-compiler"><a class="header" href="#simulations-via-our-compiler">Simulations via our compiler</a></h3>
<p>In the future, we plan to introduce our “extended” version of Solidity with more supported opcodes than the original
one. However, right now it was beyond the capacity of the team to do, so in order to represent accessing ZKsync-specific
opcodes, we use <code>call</code> opcode with certain constant parameters that will be automatically replaced by the compiler with
zkEVM native opcode.</p>
<p>Example:</p>
<pre><code class="language-solidity">function getCodeAddress() internal view returns (address addr) {
  address callAddr = CODE_ADDRESS_CALL_ADDRESS;
  assembly {
    addr := staticcall(0, callAddr, 0, 0xFFFF, 0, 0)
  }
}

</code></pre>
<p>In the example above, the compiler will detect that the static call is done to the constant <code>CODE_ADDRESS_CALL_ADDRESS</code>
and so it will replace it with the opcode for getting the code address of the current execution.</p>
<p>Full list of opcode simulations can be found
<a href="https://github.com/code-423n4/2023-10-zksync/blob/main/docs/VM%20Section/How%20compiler%20works/instructions/extensions/call.md">here</a>.</p>
<p>We also use
<a href="https://github.com/code-423n4/2023-10-zksync/blob/main/docs/VM%20Section/How%20compiler%20works/instructions/extensions/verbatim.md">verbatim-like</a>
statements to access ZKsync-specific opcodes in the bootloader.</p>
<p>All the usages of the simulations in our Solidity code are implemented in the
<a href="https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractHelper.sol">SystemContractHelper</a>
library and the
<a href="https://github.com/code-423n4/2023-10-zksync/blob/main/code/system-contracts/contracts/libraries/SystemContractsCaller.sol">SystemContractsCaller</a>
library.</p>
<p><strong>Simulating</strong> <code>near_call</code> <strong>(in Yul only)</strong></p>
<p>In order to use <code>near_call</code> i.e. to call a local function, while providing a limit of ergs (gas) that this function can
use, the following syntax is used:</p>
<p>The function should contain <code>ZKSYNC_NEAR_CALL</code> string in its name and accept at least 1 input parameter. The first input
parameter is the packed ABI of the <code>near_call</code>. Currently, it is equal to the number of ergs to be passed with the
<code>near_call</code>.</p>
<p>Whenever a <code>near_call</code> panics, the <code>ZKSYNC_CATCH_NEAR_CALL</code> function is called.</p>
<p><em>Important note:</em> the compiler behaves in a way that if there is a <code>revert</code> in the bootloader, the
<code>ZKSYNC_CATCH_NEAR_CALL</code> is not called and the parent frame is reverted as well. The only way to revert only the
<code>near_call</code> frame is to trigger VM’s <em>panic</em> (it can be triggered with either invalid opcode or out of gas error).</p>
<p><em>Important note 2:</em> The 63/64 rule does not apply to <code>near_call</code>. Also, if 0 gas is provided to the near call, then
actually all of the available gas will go to it.</p>
<h3 id="notes-on-security"><a class="header" href="#notes-on-security">Notes on security</a></h3>
<p>To prevent unintended substitution, the compiler requires <code>--system-mode</code> flag to be passed during compilation for the
above substitutions to work.</p>
<h2 id="bytecode-hashes"><a class="header" href="#bytecode-hashes">Bytecode hashes</a></h2>
<p>On ZKsync the bytecode hashes are stored in the following format:</p>
<ul>
<li>The 0th byte denotes the version of the format. Currently the only version that is used is “1”.</li>
<li>The 1st byte is <code>0</code> for deployed contracts’ code and <code>1</code> for the contract code
<a href="https://github.com/matter-labs/zksync-era/blob/main/docs/specs/zk_evm/system_contracts.md#constructing-vs-non-constructing-code-hash">that is being constructed</a>.</li>
<li>The 2nd and 3rd bytes denote the length of the contract in 32-byte words as big-endian 2-byte number.</li>
<li>The next 28 bytes are the last 28 bytes of the sha256 hash of the contract’s bytecode.</li>
</ul>
<p>The bytes are ordered in little-endian order (i.e. the same way as for <code>bytes32</code> ).</p>
<h3 id="bytecode-validity"><a class="header" href="#bytecode-validity">Bytecode validity</a></h3>
<p>A bytecode is valid if it:</p>
<ul>
<li>Has its length in bytes divisible by 32 (i.e. consists of an integer number of 32-byte words).</li>
<li>Has a length of less than 2^16 words (i.e. its length in words fits into 2 bytes).</li>
<li>Has an odd length in words (i.e. the 3rd byte is an odd number).</li>
</ul>
<p>Note, that it does not have to consist of only correct opcodes. In case the VM encounters an invalid opcode, it will
simply revert (similar to how EVM would treat them).</p>
<p>A call to a contract with invalid bytecode can not be proven. That is why it is <strong>essential</strong> that no contract with
invalid bytecode is ever deployed on ZKsync. It is the job of the
<a href="https://github.com/matter-labs/zksync-era/blob/main/docs/specs/zk_evm/system_contracts.md#knowncodestorage">KnownCodesStorage</a>
to ensure that all allowed bytecodes in the system are valid.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../guides/advanced/11_compression.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../guides/advanced/13_zk_intuition.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../guides/advanced/11_compression.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../guides/advanced/13_zk_intuition.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../js/version-box.js"></script>
        <script src="../../js/mermaid-init.js"></script>


    </div>
    </body>
</html>

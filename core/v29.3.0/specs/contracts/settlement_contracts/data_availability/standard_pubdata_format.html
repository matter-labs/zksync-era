<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Standard pubdata format - ZKsync Era Documentation</title>


        <!-- Custom HTML head -->
        <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../../../favicon.svg">
        <link rel="shortcut icon" href="../../../../favicon.png">
        <link rel="stylesheet" href="../../../../css/variables.css">
        <link rel="stylesheet" href="../../../../css/general.css">
        <link rel="stylesheet" href="../../../../css/chrome.css">
        <link rel="stylesheet" href="../../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../../../css/version-box.css">
        <link rel="stylesheet" href="../../../.././css/mdbook-admonish.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZKsync Era Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-era/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-era/tree/main/docs/src/specs/contracts/settlement_contracts/data_availability/standard_pubdata_format.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="standard-pubdata-format"><a class="header" href="#standard-pubdata-format">Standard pubdata format</a></h1>
<p>With the introduction of <a href="./custom_da.html">custom DA validation</a>, different pubdata logic can be applied for each chain (including calldata-based pubdata); however, ZK chains are generally optimized for a state-diffs–based rollup model.</p>
<p>This document describes how the standard pubdata format looks. This is the format that is enforced for <a href="../../chain_management/admin_role.html#ispermanentrollup-setting">permanent rollup chains</a>.</p>
<p>Pubdata in ZKsync can be divided up into 4 categories:</p>
<ol>
<li>L2 to L1 Logs</li>
<li>L2 to L1 Messages</li>
<li>Smart Contract Bytecodes</li>
<li>Storage Writes</li>
</ol>
<p>Using data corresponding to these 4 facets across all executed batches, we’re able to reconstruct the full state of L2. To restore the state we just need to filter all of the transactions to the L1 ZKsync contract for only the <code>commitBatches</code> transactions where the proposed block has been referenced by a corresponding <code>executeBatches</code> call (the reason for this is that a committed or even proven block can be reverted but an executed one cannot). Once we have all the committed batches that have been executed, we will then pull the transaction input and the relevant fields, applying them in order to reconstruct the current state of L2.</p>
<h2 id="l2l1-communication"><a class="header" href="#l2l1-communication">L2→L1 communication</a></h2>
<p>We will implement the calculation of the Merkle root of the L2→L1 messages via a system contract as part of the <code>L1Messenger</code>. Basically, whenever a new user-emitted log that needs to be Merklized is created, the <code>L1Messenger</code> contract will append it to its rolling hash and then, at the end of the batch during the formation of the blob, it will receive the original preimages from the operator, verify their consistency, and send those to the <code>L2DAValidator</code> library to facilitate the DA protocol.</p>
<p>We will now refer to the logs that are created by users and Merklized as <em>user</em> logs, and the logs that are emitted natively by the VM as <em>system</em> logs. Here is a short comparison table for better understanding:</p>
<div class="table-wrapper"><table><thead><tr><th>System logs</th><th>User logs</th></tr></thead><tbody>
<tr><td>Emitted by VM via an opcode.</td><td>VM knows nothing about them.</td></tr>
<tr><td>Consistency and correctness are enforced by the verifier on L1 (i.e. their hash is part of the block commitment).</td><td>Consistency and correctness is enforced by the L1Messenger system contract. The correctness of the behavior of the L1Messenger is enforced implicitly by the prover in the sense that it proves the correctness of the execution overall.</td></tr>
<tr><td>We don’t calculate their Merkle root.</td><td>We calculate their Merkle root on the L1Messenger system contract.</td></tr>
<tr><td>There is a constant small number of these logs.</td><td>We can have as many as possible as long as the commitBatches function on L1 remains executable (it is the job of the operator to ensure that only such transactions are selected).</td></tr>
<tr><td>In EIP-4844 they will remain part of the calldata.</td><td>In EIP-4844 they will become part of the blobs.</td></tr>
</tbody></table>
</div>
<h3 id="backwards-compatibility"><a class="header" href="#backwards-compatibility">Backwards-compatibility</a></h3>
<p>Note that to maintain a unified interface with the previous version of the protocol, the leaves of the Merkle tree will have to maintain the following structure:</p>
<pre><code class="language-solidity">struct L2Log {
  uint8 l2ShardId;
  bool isService;
  uint16 txNumberInBlock;
  address sender;
  bytes32 key;
  bytes32 value;
}
</code></pre>
<p>The leaf will look as follows:</p>
<pre><code class="language-solidity">bytes32 hashedLog = keccak256(
    abi.encodePacked(_log.l2ShardId, _log.isService, _log.txNumberInBlock, _log.sender, _log.key, _log.value)
);
</code></pre>
<p><code>keccak256</code> will continue being the function for the Merkle tree.</p>
<p>To put it shortly, the proofs for L2→L1 log inclusion will continue to have exactly the same format as they did in the pre-Boojum system, which avoids breaking changes for SDKs and bridges alike.</p>
<h3 id="implementation-of-l1messenger"><a class="header" href="#implementation-of-l1messenger">Implementation of <code>L1Messenger</code></a></h3>
<p>The L1Messenger contract will maintain a rolling hash of all the L2ToL1 logs <code>chainedLogsHash</code> as well as the rolling hash of messages <code>chainedMessagesHash</code>. Whenever a contract wants to send an L2→L1 log, the following operation will be <a href="https://github.com/matter-labs/era-contracts/blob/b43cf6b3b069c85aec3cd61d33dd3ae2c462c896/system-contracts/contracts/L1Messenger.sol#L73">applied</a>:</p>
<pre><code>chainedLogsHash = keccak256(chainedLogsHash, hashedLog)
</code></pre>
<p>L2→L1 logs have the same 88-byte format as in the current version of ZKsync.</p>
<p>Note that the user is charged for the future computation needed to calculate the final Merkle root. It is roughly 4× higher than the cost to calculate the hash of the leaf, since the eventual tree might be 4× the number of nodes. In any case, this will likely be a relatively negligible part compared to the cost of the pubdata.</p>
<p>At the end of the execution, the bootloader will <a href="https://github.com/matter-labs/era-contracts/blob/b43cf6b3b069c85aec3cd61d33dd3ae2c462c896/system-contracts/bootloader/bootloader.yul#L2676">provide</a> a list of all the L2ToL1 logs (this will be provided by the operator in the memory of the bootloader). The L1Messenger checks that the rolling hash from the provided logs is the same as in the <code>chainedLogsHash</code> and calculates the Merkle tree of the provided messages. Right now, we always build the Merkle tree of size <code>16384</code>, but we charge the user as if the tree were built dynamically based on the number of leaves. The implementation of the dynamic tree has been postponed until later upgrades.</p>
<blockquote>
<p>Note that, unlike most other parts of pubdata, the user L2→L1 must always be validated by the trusted <code>L1Messenger</code> system contract. If we moved this responsibility to <code>L2DAValidator</code> library it would be possible for a malicious operator to provide incorrect data and forge transactions out of names of certain users.</p>
</blockquote>
<h3 id="long-l2l1-messages--bytecodes"><a class="header" href="#long-l2l1-messages--bytecodes">Long L2→L1 messages &amp; bytecodes</a></h3>
<p>If the user wants to send an L2→L1 message, its preimage is <a href="https://github.com/matter-labs/era-contracts/blob/b43cf6b3b069c85aec3cd61d33dd3ae2c462c896/system-contracts/contracts/L1Messenger.sol#L126">appended</a> to the message’s rolling hash to:</p>
<pre><code>chainedMessagesHash = keccak256(abi.encode(chainedMessagesHash, hash));
</code></pre>
<p>A very similar approach for bytecodes is used, where their rolling hash is calculated and then the preimages are provided at the end of the batch to form the full pubdata for the batch.</p>
<p>Note that for backward compatibility, just like before, any long message or bytecode is accompanied by the corresponding user L2→L1 log.</p>
<h3 id="using-system-l2l1-logs-vs-the-user-logs"><a class="header" href="#using-system-l2l1-logs-vs-the-user-logs">Using system L2→L1 logs vs the user logs</a></h3>
<p>The content of the L2→L1 logs by the L1Messenger will go to the blob of EIP-4844. Meaning that all the data that belongs to the tree by L1Messenger’s L2→L1 logs should not be needed during block commitment. Also, note that in the future we will remove the calculation of the Merkle root of the built-in L2→L1 messages.</p>
<p>The only places where the built-in L2→L1 messaging should continue to be used:</p>
<ul>
<li>Logs by SystemContext (they are needed on commit to check the previous block hash).</li>
<li>Logs by L1Messenger for the Merkle root of the L2→L1 tree as well as the data needed for <code>L1DAValidator</code>.</li>
<li><code>chainedPriorityTxsHash</code> and <code>numberOfLayer1Txs</code> from the bootloader (read more about it below).</li>
</ul>
<h3 id="obtaining-txnumberinblock"><a class="header" href="#obtaining-txnumberinblock">Obtaining <code>txNumberInBlock</code></a></h3>
<p>To have the same log format, the <code>txNumberInBlock</code> must be obtained. While it is internally counted in the VM, there is currently no opcode to retrieve this number. We will have a public variable <code>txNumberInBlock</code> in the <code>SystemContext</code>, which will be incremented with each new transaction and from which it can be retrieved. It is <a href="https://github.com/matter-labs/era-contracts/blob/b43cf6b3b069c85aec3cd61d33dd3ae2c462c896/system-contracts/contracts/SystemContext.sol#L515">zeroed out</a> at the end of the batch.</p>
<h3 id="bootloader-implementation"><a class="header" href="#bootloader-implementation">Bootloader implementation</a></h3>
<p>The bootloader has a memory segment dedicated to the ABI-encoded data of the L1ToL2Messenger to perform the <code>publishPubdataAndClearState</code> call.</p>
<p>At the end of the execution of the batch, the operator should provide the corresponding data in the bootloader memory, i.e., user L2→L1 logs, long messages, bytecodes, etc. After that, the <a href="https://github.com/matter-labs/era-contracts/blob/b43cf6b3b069c85aec3cd61d33dd3ae2c462c896/system-contracts/bootloader/bootloader.yul#L2676">call</a> is performed to the <code>L1Messenger</code> system contract, which would call the <code>L2DAValidator</code> library to check the adherence of the pubdata to the specified format.</p>
<h2 id="bytecode-publishing"><a class="header" href="#bytecode-publishing">Bytecode Publishing</a></h2>
<p>Within pubdata, bytecodes are published in one of two ways:<br />
(1) uncompressed as part of the bytecodes array and<br />
(2) compressed via long L2→L1 messages.</p>
<h3 id="uncompressed-bytecode-publishing"><a class="header" href="#uncompressed-bytecode-publishing">Uncompressed Bytecode Publishing</a></h3>
<p>Uncompressed bytecodes are included within the <code>totalPubdata</code> bytes and have the following format:</p>
<pre><code>number of bytecodes || forEachBytecode (length of bytecode(n) || bytecode(n))
</code></pre>
<h3 id="compressed-bytecode-publishing"><a class="header" href="#compressed-bytecode-publishing">Compressed Bytecode Publishing</a></h3>
<p>Unlike uncompressed bytecode, which is published as part of <code>factoryDeps</code>, compressed bytecodes are published as long L2→L1 messages, which can be seen <a href="https://github.com/matter-labs/era-contracts/blob/b43cf6b3b069c85aec3cd61d33dd3ae2c462c896/system-contracts/contracts/Compressor.sol#L78">here</a>.</p>
<h4 id="bytecode-compression-algorithm--server-side"><a class="header" href="#bytecode-compression-algorithm--server-side">Bytecode Compression Algorithm — Server Side</a></h4>
<p>This is the part that is responsible for taking bytecode that has already been chunked into 8-byte words, performing validation, and compressing it.</p>
<p>Each 8-byte word from the chunked bytecode is assigned a 2-byte index (constraint on size of dictionary of chunk → index is 2^16 – 1 elements). The length of the dictionary, dictionary entries (index assumed through order), and indexes are all concatenated together to yield the final compressed version.</p>
<p>For bytecode to be considered valid, it must satisfy the following:</p>
<ol>
<li>Bytecode length must be less than 2097120 ((2^16 – 1) * 32) bytes.</li>
<li>Bytecode length must be a multiple of 32.</li>
<li>Number of 32-byte words cannot be even.</li>
</ol>
<p>The following is a simplified version of the algorithm:</p>
<pre><code class="language-python">statistic: Map[chunk, (count, first_pos)]
dictionary: Map[chunk, index]
encoded_data: List[index]

for position, chunk in chunked_bytecode:
 if chunk is in statistic:
  statistic[chunk].count += 1
 else:
  statistic[chunk] = (count=1, first_pos=pos)

# We want the more frequently used bytes to have smaller ids to save on calldata (zero bytes cost less)
statistic.sort(primary=count, secondary=first_pos, order=desc)

for index, chunk in enumerated(sorted_statistics):
  dictionary[chunk] = index

for chunk in chunked_bytecode:
 encoded_data.append(dictionary[chunk])

return [len(dictionary), dictionary.keys(order=index asc), encoded_data]
</code></pre>
<h4 id="verification-and-publishing--l2-contract"><a class="header" href="#verification-and-publishing--l2-contract">Verification And Publishing — L2 Contract</a></h4>
<p>The function <code>publishCompressBytecode</code> takes in both the original <code>_bytecode</code> and the <code>_rawCompressedData</code>, the latter of which comes from the output of the server’s compression algorithm. Looping over the encoded data derived from <code>_rawCompressedData</code>, the corresponding chunks are pulled from the dictionary and compared to the original bytecode, reverting if there is a mismatch. After the encoded data has been verified, it is published to L1 and marked accordingly within the <code>KnownCodesStorage</code> contract.</p>
<p>Pseudo-code implementation:</p>
<pre><code class="language-python">length_of_dict = _rawCompressedData[:2]
dictionary = _rawCompressedData[2:2 + length_of_dict * 8] # need to offset by bytes used to store length (2) and multiply by 8 for chunk size
encoded_data = _rawCompressedData[2 + length_of_dict * 8:]

assert(len(dictionary) % 8 == 0) # each element should be 8 bytes
assert(num_entries(dictionary) &lt;= 2^16)
assert(len(encoded_data) * 4 == len(_bytecode)) # given that each chunk is 8 bytes and each index is 2 bytes they should differ by a factor of 4

for (index, dict_index) in list(enumerate(encoded_data)):
 encoded_chunk = dictionary[dict_index]
 real_chunk = _bytecode.readUint64(index * 8) # need to pull from index * 8 to account for difference in element size
 verify(encoded_chunk == real_chunk)

# Sending the compressed bytecode to L1 for data availability
sendToL1(_rawCompressedBytecode)
markAsPublished(hash(_bytecode))
</code></pre>
<h2 id="storage-diff-publishing"><a class="header" href="#storage-diff-publishing">Storage diff publishing</a></h2>
<p>ZKsync is a state-diff–based rollup and so publishing the correct state diffs plays an integral role in ensuring data availability.</p>
<h3 id="difference-between-initial-and-repeated-writes"><a class="header" href="#difference-between-initial-and-repeated-writes">Difference between initial and repeated writes</a></h3>
<p>ZKsync publishes state changes that happened within the batch instead of transactions themselves. Meaning that, for instance, some storage slot <code>S</code> under account <code>A</code> has changed to value <code>V</code>, we could publish a triple of <code>A,S,V</code>. Users, by observing all the triples, could restore the state of ZKsync. However, note that our tree, unlike Ethereum’s one, is not account based (i.e. there is no first layer of depth 160 of the Merkle tree corresponding to accounts and a second layer of depth 256 of the Merkle tree corresponding to users). Our tree is “flat,” i.e. a slot <code>S</code> under account <code>A</code> is just stored in the leaf number <code>H(S,A)</code>. Our tree is of depth 256 + 8 (the 256 is for these hashed account/key pairs and 8 is for potential shards in the future; we currently have only one shard and it is irrelevant for the rest of the document).</p>
<p>We call this <code>H(S,A)</code> a <em>derived key</em>, because it is derived from the address and the actual key in the storage of the account. Since our tree is flat, whenever a change happens, we can publish a pair <code>DK, V</code>, where <code>DK=H(S,A)</code>.</p>
<p>However, there is an optimization that can be done:</p>
<ul>
<li>Whenever a change to a key is used for the first time, we publish a pair of <code>DK,V</code> and we assign some sequential id to this derived key. This is called an <em>initial write</em>. It happens for the first time and that’s why we must publish the full key.</li>
<li>If this storage slot is published in some of the subsequent batches, instead of publishing the whole <code>DK</code>, we can use the sequential id instead. This is called a <em>repeated write</em>.</li>
</ul>
<p>For instance, if the slots <code>A</code>, <code>B</code> (I’ll use Latin letters instead of 32-byte hashes for readability) changed their values to <code>12</code>, <code>13</code> accordingly in the batch, they will be published in the following format:</p>
<ul>
<li><code>(A, 12), (B, 13)</code>. Let’s say that the last sequential id ever used is 6. Then, <code>A</code> will receive the id of 7 and <code>B</code> will receive the id of 8.</li>
</ul>
<p>Let’s say that in the next block, they change their values to <code>13</code>, <code>14</code>. Then, their diff will be published in the following format:</p>
<ul>
<li><code>(7, 13), (8, 14)</code>.</li>
</ul>
<p>The id is permanently assigned to each storage key that was ever published. While in the description above it may not seem like a huge boost, each <code>DK</code> is 32 bytes long and the id is at most 8 bytes long.</p>
<p>We call this id <em>enumeration_index</em>.</p>
<p>Note that the enumeration indexes are assigned in the order of a sorted array of (address, key) pairs, i.e. they are internally sorted. The enumeration indexes are part of the state Merkle tree; it is <strong>crucial</strong> that the initial writes are published in the correct order, so that anyone could restore the correct enumeration indexes for the storage slots. In addition, an enumeration index of <code>0</code> indicates that the storage write is an initial write.</p>
<h3 id="state-diffs-structure"><a class="header" href="#state-diffs-structure">State diffs structure</a></h3>
<p>Firstly, let’s define what we mean by <em>state diffs</em>. A <em>state diff</em> is an element of the following structure.</p>
<p><a href="https://github.com/matter-labs/zksync-protocol/blob/main/crates/circuit_encodings/src/state_diff_record.rs#L8">State diff structure</a>.</p>
<p>Basically, it contains all the values which might interest us about the state diff:</p>
<ul>
<li><code>address</code> where the storage has been changed.</li>
<li><code>key</code> (the original key inside the address).</li>
<li><code>derived_key</code> — <code>H(key, address)</code> as described in the previous section.
<ul>
<li>Note: the hashing algorithm currently used here is <code>Blake2s</code>.</li>
</ul>
</li>
<li><code>enumeration_index</code> — enumeration index as explained above. It is equal to 0 if the write is initial and contains the non-zero enumeration index if it is a repeated write (indexes start from 1).</li>
<li><code>initial_value</code> — the value that was present in the key at the start of the batch.</li>
<li><code>final_value</code> — the value that the key has changed to by the end of the batch.</li>
</ul>
<p>We will consider <code>stateDiffs</code> an array of such objects, sorted by (address, key).</p>
<p>This is the internal structure that is used by the circuits to represent the state diffs. The most basic “compression” algorithm is the one described above:</p>
<ul>
<li>For initial writes, write the pair (<code>derived_key</code>, <code>final_value</code>).</li>
<li>For repeated writes, write the pair (<code>enumeration_index</code>, <code>final_value</code>).</li>
</ul>
<p>Note that values like <code>initial_value</code>, <code>address</code>, and <code>key</code> are not used in the “simplified” algorithm above, but they will be helpful for more advanced compression algorithms in the future. The <a href="#state-diff-compression-format">algorithm</a> for Boojum already utilizes the difference between the <code>initial_value</code> and <code>final_value</code> to save on pubdata.</p>
<h3 id="how-the-new-pubdata-verification-works"><a class="header" href="#how-the-new-pubdata-verification-works">How the new pubdata verification works</a></h3>
<h4 id="l2"><a class="header" href="#l2"><strong>L2</strong></a></h4>
<ol>
<li>The operator provides both full <code>stateDiffs</code> (i.e. the array of the structs above) and the compressed state diffs (i.e. the array containing the state diffs, compressed by the algorithm explained <a href="#state-diff-compression-format">below</a>).</li>
<li>The <code>L2DAValidator</code> library must verify that the compressed version is consistent with the original stateDiffs and send the <em>hash</em> of the <code>stateDiffs</code> to its L1 counterpart. It will also include the compressed state diffs in the totalPubdata to be published onto L1.</li>
</ol>
<h4 id="l1"><a class="header" href="#l1"><strong>L1</strong></a></h4>
<ol>
<li>During block commitment, the standard DA protocol follows and the <code>L1DAValidator</code> is responsible for checking that the operator has provided the preimage for the <code>_totalPubdata</code>. More on how this is checked can be seen <a href="./rollup_da.html">here</a>.</li>
<li>The block commitment <a href="https://github.com/matter-labs/era-contracts/blob/b43cf6b3b069c85aec3cd61d33dd3ae2c462c896/l1-contracts/contracts/state-transition/chain-deps/facets/Executor.sol#L550">includes</a> <em>the hash of the <code>stateDiffs</code></em>. Thus, ZKP verification will fail if the provided stateDiffs hash is not correct.</li>
</ol>
<p>It is a secure construction because the proof can be verified only if both the execution was correct and the hash of the <code>stateDiffs</code> is correct. This means that the <code>L2DAValidator</code> library indeed received the array of correct <code>stateDiffs</code> and, assuming the <code>L2DAValidator</code> is working correctly, double-checked that the compression is in the correct format, while L1 contracts at the commit stage double-checked that the operator provided the preimage for the compressed state diffs.</p>
<h3 id="state-diff-compression-format"><a class="header" href="#state-diff-compression-format">State diff compression format</a></h3>
<p>The following algorithm is used for the state diff compression:</p>
<p><a href="./state_diff_compression_v1_spec.html">State diff compression v1 spec</a></p>
<h2 id="general-pubdata-format"><a class="header" href="#general-pubdata-format">General pubdata format</a></h2>
<p>The <code>totalPubdata</code> has the following structure:</p>
<ol>
<li>First 4 bytes — the number of user L2→L1 logs in the batch.</li>
<li>Then, the concatenation of packed L2→L1 user logs.</li>
<li>Next, 4 bytes — the number of long L2→L1 messages in the batch.</li>
<li>Then, the concatenation of L2→L1 messages, each in the format <code>&lt;4 byte length || actual_message&gt;</code>.</li>
<li>Next, 4 bytes — the number of uncompressed bytecodes in the batch.</li>
<li>Then, the concatenation of uncompressed bytecodes, each in the format <code>&lt;4 byte length || actual_bytecode&gt;</code>.</li>
<li>Next, 4 bytes — the length of the compressed state diffs.</li>
<li>Then, state diffs are compressed by the spec <a href="#state-diff-compression-format">above</a>.</li>
</ol>
<p>The interface for committing batches is the following:</p>
<pre><code class="language-solidity">/// @notice Data needed to commit new batch
/// @param batchNumber Number of the committed batch
/// @param timestamp Unix timestamp denoting the start of the batch execution
/// @param indexRepeatedStorageChanges The serial number of the shortcut index that's used as a unique identifier for storage keys that were used twice or more
/// @param newStateRoot The state root of the full state tree
/// @param numberOfLayer1Txs Number of priority operations to be processed
/// @param priorityOperationsHash Hash of all priority operations from this batch
/// @param bootloaderHeapInitialContentsHash Hash of the initial contents of the bootloader heap. In practice it serves as the commitment to the transactions in the batch.
/// @param eventsQueueStateHash Hash of the events queue state. In practice it serves as the commitment to the events in the batch.
/// @param systemLogs Concatenation of all L2→L1 system logs in the batch
/// @param totalL2ToL1Pubdata Total pubdata committed to as part of bootloader run. Contents are: l2Tol1Logs &lt;&gt; l2Tol1Messages &lt;&gt; publishedBytecodes &lt;&gt; stateDiffs
struct CommitBatchInfo {
  uint64 batchNumber;
  uint64 timestamp;
  uint64 indexRepeatedStorageChanges;
  bytes32 newStateRoot;
  uint256 numberOfLayer1Txs;
  bytes32 priorityOperationsHash;
  bytes32 bootloaderHeapInitialContentsHash;
  bytes32 eventsQueueStateHash;
  bytes systemLogs;
  bytes totalL2ToL1Pubdata;
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../../specs/contracts/settlement_contracts/data_availability/rollup_da.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../../specs/contracts/settlement_contracts/data_availability/state_diff_compression_v1_spec.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../../specs/contracts/settlement_contracts/data_availability/rollup_da.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../../specs/contracts/settlement_contracts/data_availability/state_diff_compression_v1_spec.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../../../ace.js"></script>
        <script src="../../../../editor.js"></script>
        <script src="../../../../mode-rust.js"></script>
        <script src="../../../../theme-dawn.js"></script>
        <script src="../../../../theme-tomorrow_night.js"></script>

        <script src="../../../../elasticlunr.min.js"></script>
        <script src="../../../../mark.min.js"></script>
        <script src="../../../../searcher.js"></script>

        <script src="../../../../clipboard.min.js"></script>
        <script src="../../../../highlight.js"></script>
        <script src="../../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../../js/version-box.js"></script>
        <script src="../../../../js/mermaid-init.js"></script>


    </div>
    </body>
</html>

//! Consensus-related functionality.

#![allow(clippy::redundant_locals)]
#![allow(clippy::needless_pass_by_ref_mut)]
use anyhow::Context as _;
use storage::{ConnectionPool, Store};
use zksync_concurrency::{ctx, error::Wrap as _, scope};
use zksync_config::configs::consensus::{ConsensusConfig, ConsensusSecrets};
use zksync_consensus_executor as executor;
use zksync_consensus_roles::validator;
use zksync_consensus_storage::BlockStore;

mod config;
mod en;
pub mod era;
mod storage;
#[cfg(test)]
pub(crate) mod testonly;
#[cfg(test)]
mod tests;

/// Task running a consensus validator for the main node.
/// Main node is currently the only leader of the consensus - i.e. it proposes all the
/// L2 blocks (generated by `Statekeeper`).
async fn run_main_node(
    ctx: &ctx::Ctx,
    cfg: ConsensusConfig,
    secrets: ConsensusSecrets,
    pool: ConnectionPool,
    chain_id: validator::ChainId,
) -> anyhow::Result<()> {
    let validator_key = config::validator_key(&secrets)
        .context("validator_key")?
        .context("missing validator_key")?;
    scope::run!(&ctx, |ctx, s| async {
        pool.connection(ctx)
            .await
            .wrap("connection()")?
            .try_init_genesis(ctx, chain_id, validator_key.public(), vec![])
            .await
            .wrap("try_init_genesis()")?;
        let (store, runner) = Store::new(ctx, pool, None).await.wrap("Store::new()")?;
        s.spawn_bg(runner.run(ctx));
        let (block_store, runner) = BlockStore::new(ctx, Box::new(store.clone()))
            .await
            .wrap("BlockStore::new()")?;
        s.spawn_bg(runner.run(ctx));
        let executor = executor::Executor {
            config: config::executor(&cfg, &secrets)?,
            block_store,
            validator: Some(executor::Validator {
                key: validator_key,
                replica_store: Box::new(store.clone()),
                payload_manager: Box::new(store.clone()),
            }),
        };
        executor.run(ctx).await
    })
    .await
}

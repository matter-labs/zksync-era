use std::sync::Arc;

use anyhow::Context as _;
use zksync_concurrency::{ctx, error::Wrap as _, scope};
use zksync_config::configs::consensus::{ConsensusConfig, ConsensusSecrets};
use zksync_consensus_engine::BlockStore;
use zksync_consensus_executor::{self as executor, attestation};
use zksync_consensus_roles::validator;

use crate::{
    config,
    storage::{ConnectionPool, Store},
};

/// Task running a consensus validator for the main node.
/// Main node is currently the only leader of the consensus - i.e. it proposes all the
/// L2 blocks (generated by `Statekeeper`).
pub async fn run_main_node(
    ctx: &ctx::Ctx,
    cfg: ConsensusConfig,
    secrets: ConsensusSecrets,
    pool: ConnectionPool,
) -> anyhow::Result<()> {
    let validator_key = config::validator_key(&secrets)
        .context("validator_key")?
        .context("missing validator_key")?;

    let res: ctx::Result<()> = scope::run!(&ctx, |ctx, s| async {
        if let Some(spec) = &cfg.genesis_spec {
            let spec = config::GenesisSpec::parse(spec).context("GenesisSpec::parse()")?;

            pool.connection(ctx)
                .await
                .wrap("connection()")?
                .adjust_global_config(ctx, &spec)
                .await
                .wrap("adjust_global_config()")?;
        }

        // The main node doesn't have a payload queue as it produces all the L2 blocks itself.
        let (store, runner) = Store::new(ctx, pool.clone(), None, None)
            .await
            .wrap("Store::new()")?;
        s.spawn_bg(async { Ok(runner.run(ctx).await.context("Store::runner()")?) });

        let global_config = pool
            .connection(ctx)
            .await
            .wrap("connection()")?
            .global_config(ctx)
            .await
            .wrap("global_config()")?
            .context("global_config() disappeared")?;
        if global_config.genesis.leader_selection
            != validator::v1::LeaderSelectionMode::Sticky(validator_key.public())
        {
            return Err(anyhow::format_err!(
                "unsupported leader selection mode - main node has to be the leader"
            )
            .into());
        }

        let (block_store, runner) = BlockStore::new(ctx, Box::new(store.clone()))
            .await
            .wrap("BlockStore::new()")?;
        s.spawn_bg(async { Ok(runner.run(ctx).await.context("BlockStore::run()")?) });

        let attestation = Arc::new(attestation::Controller::new(None));
        let executor = executor::Executor {
            config: config::executor(&cfg, &secrets, &global_config, None)?,
            block_store,
            validator: Some(executor::Validator {
                key: validator_key,
                replica_store: Box::new(store.clone()),
                payload_manager: Box::new(store.clone()),
            }),
            attestation,
        };

        tracing::info!("running the main node executor");
        executor.run(ctx).await.context("executor")?;
        Ok(())
    })
    .await;
    match res {
        Ok(()) | Err(ctx::Error::Canceled(_)) => Ok(()),
        Err(ctx::Error::Internal(err)) => Err(err),
    }
}

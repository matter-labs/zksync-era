//! Consensus-related functionality.

#![allow(clippy::redundant_locals)]
#![allow(clippy::needless_pass_by_ref_mut)]

use zksync_concurrency::{ctx, error::Wrap as _, scope};
use zksync_consensus_executor as executor;
use zksync_consensus_roles::validator;
use zksync_config::configs::consensus::{ConsensusConfig, ConsensusSecrets};
use storage::Store;

pub use self::{fetcher::*};

mod config;
pub mod era;
mod fetcher;
mod storage;
#[cfg(test)]
pub(crate) mod testonly;
#[cfg(test)]
mod tests;


/// Task generating consensus certificates for the L2 blocks generated by `StateKeeper`.
/// Broadcasts the blocks with certificates to gossip network peers.
pub async fn run_main_node(ctx: &ctx::Ctx, cfg: ConsensusConfig, secrets: ConsensusSecrets, mut store: Store, chain_id: validator::ChainId) -> anyhow::Result<()> {
    let validator_key = config::validator_key(secrets).context("validator_key")?;
    scope::run!(&ctx, |ctx, s| async {
        store
            .try_init_genesis(ctx, chain_id, &validator_key.public())
            .await
            .wrap("block_store.try_init_genesis()")?;
        let (block_store, runner) = store
            .clone()
            .into_block_store(ctx, None)
            .await
            .wrap("into_block_store()")?;
        s.spawn_bg(runner.run(ctx));
        let executor = executor::Executor {
            config: config::executor(&cfg,&secrets)?,
            block_store,
            validator: Some(executor::Validator {
                key: validator_key,
                replica_store: Box::new(store.clone()),
                payload_manager: Box::new(store.clone()),
            }),
        };
        executor.run(ctx).await
    })
    .await
}

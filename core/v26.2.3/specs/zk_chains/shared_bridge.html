<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shared Bridge - ZKsync Era Documentation</title>


        <!-- Custom HTML head -->
        <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../css/version-box.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZKsync Era Documentation</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-era/tree/main/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/matter-labs/zksync-era/tree/main/docs/src/specs/zk_chains/shared_bridge.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="shared-bridge"><a class="header" href="#shared-bridge">Shared Bridge</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Ethereum’s future is rollup-centric. This means breaking with the current paradigm of isolated EVM chains to
infrastructure that is focused on an ecosystem of interconnected zkEVMs, (which we name ZK Chains). This ecosystem will
be grounded on Ethereum, requiring the appropriate L1 smart contracts. Here we outline our ZK Stack approach for these
contracts, their interfaces, the needed changes to the existing architecture, as well as future features to be
implemented.</p>
<p>If you want to know more about ZK Chains, check this
<a href="https://blog.matter-labs.io/introduction-to-hyperchains-fdb33414ead7">blog post</a>, or go through
<a href="https://docs.zksync.io/zk-stack/concepts/zk-chains">our docs</a>.</p>
<h3 id="high-level-design"><a class="header" href="#high-level-design">High-level design</a></h3>
<p>We want to create a system where:</p>
<ul>
<li>ZK Chains should be launched permissionlessly within the ecosystem.</li>
<li>Interop should enable unified liquidity for assets across the ecosystem.</li>
<li>Multi-chain smart contracts need to be easy to develop, which means easy access to traditional bridges, and other
supporting architecture.</li>
</ul>
<p>ZK Chains have specific trust requirements - they need to satisfy certain common standards so that they can trust each
other. This means a single set of L1 smart contracts has to manage the proof verification for all ZK Chains, and if the
proof system is upgraded, all chains have to be upgraded together. New chains will be able to be launched
permissionlessly in the ecosystem according to this shared standard.</p>
<p>To allow unified liquidity each L1 asset (ETH, ERC20, NFTs) will have a single bridge contract on L1 for the whole
ecosystem. These shared bridges will allow users to deposit, withdraw and transfer from any ZK Chain in the ecosystem.
These shared bridges are also responsible for deploying and maintaining their counterparts on the ZK Chains. The
counterparts will be asset contracts extended with bridging functionality.</p>
<p>To enable the bridging functionality:</p>
<ul>
<li>On the L1 we will add a Bridgehub contract which connects asset bridges to all the ZK Chains. This will also be the
contract that holds the ETH for the ecosystem.</li>
<li>On the ZK Chain side we will add special system contracts that enable these features.</li>
</ul>
<p>We want to make the ecosystem as modular as possible, giving developers the ability to modify the architecture as
needed; consensus mechanism, staking, and DA requirements.</p>
<p>We also want the system to be forward-compatible, with future updates like L3s, proof aggregation, alternative State
Transition (ST) contracts, and ZK IP (which would allow unified liquidity between all STs). Those future features have
to be considered in this initial design, so it can evolve to support them (meaning, chains being launched now will still
be able to leverage them when available).</p>
<hr />
<h2 id="architecture"><a class="header" href="#architecture">Architecture</a></h2>
<h3 id="general-architecture"><a class="header" href="#general-architecture">General Architecture</a></h3>
<p><img src="./img/contractsExternal.png" alt="Contracts" /></p>
<h3 id="components"><a class="header" href="#components">Components</a></h3>
<h4 id="bridgehub"><a class="header" href="#bridgehub">Bridgehub</a></h4>
<ul>
<li>
<p>Acts as a hub for bridges, so that they have a single point of communication with all ZK Chain contracts. This allows
L1 assets to be locked in the same contract for all ZK Chains. The <code>Bridgehub</code> also implements the following features:</p>
</li>
<li>
<p><code>Registry</code> This is where ZK Chains can register, starting in a permissioned manner, but with the goal to be
permissionless in the future. This is where their <code>chainID</code> is determined. Chains on Gateway will also register here.
This <code>Registry</code> is also where Chain Type Manager contracts should register. Each chain has to specify its desired CTM
when registering (Initially, only one will be available).</p>
<pre><code>function newChain(
        uint256 _chainId,
        address _chainTypeManager
    ) external returns (uint256 chainId);

function newChainTypeManager(address _chainTypeManager) external;
</code></pre>
</li>
<li>
<p><code>BridgehubMailbox</code> routes messages to the Diamond proxy’s Mailbox facet based on chainID</p>
<ul>
<li>Same as the current zkEVM
<a href="https://github.com/matter-labs/era-contracts/blob/main/l1-contracts/contracts/zksync/facets/Mailbox.sol">Mailbox</a>,
just with chainId,</li>
<li>This is where L2 transactions can be requested.</li>
</ul>
<pre><code>  function requestL2TransactionTwoBridges(
      L2TransactionRequestTwoBridgesOuter calldata _request
  )
</code></pre>
<pre><code>struct L2TransactionRequestTwoBridgesOuter {
  uint256 chainId;
  uint256 mintValue;
  uint256 l2Value;
  uint256 l2GasLimit;
  uint256 l2GasPerPubdataByteLimit;
  address refundRecipient;
  address secondBridgeAddress;
  uint256 secondBridgeValue;
  bytes secondBridgeCalldata;
}
</code></pre>
</li>
</ul>
<pre><code>  struct L2TransactionRequestTwoBridgesInner {
    bytes32 magicValue;
    address l2Contract;
    bytes l2Calldata;
    bytes[] factoryDeps;
    bytes32 txDataHash;
}
</code></pre>
<ul>
<li>
<p>The <code>requestL2TransactionTwoBridges</code> function should be used most of the time when bridging to a chain ( the exeption
is when the user bridges directly to a contract on the L2, without using a bridge contract on L1). The logic of it is
the following:</p>
<ul>
<li>The user wants to bridge to chain with the provided <code>L2TransactionRequestTwoBridgesOuter.chainId</code>.</li>
<li>Two bridges are called, the baseTokenBridge (i.e. the L1SharedBridge or L1AssetRouter after the Gateway upgrade) and
an arbitrary second bridge. The Bridgehub will provide the original caller address to both bridges, which can
request that the appropriate amount of tokens are transferred from the caller to the bridge. The caller has to set
the appropriate allowance for both bridges. (Often the bridges coincide, but they don’t have to).</li>
<li>The <code>L2TransactionRequestTwoBridgesOuter.mintValue</code> is the amount of baseTokens that will be minted on L2. This is
the amount of tokens that the baseTokenBridge will request from the user. If the baseToken is Eth, it will be
forwarded to the baseTokenBridge.</li>
<li>The <code>L2TransactionRequestTwoBridgesOuter.l2Value</code> is the amount of tokens that will be deposited on L2. The second
bridge and the Mailbox receives this as an input (although our second bridge does not use the value).</li>
<li>The <code>L2TransactionRequestTwoBridgesOuter.l2GasLimit</code> is the maximum amount of gas that will be spent on L2 to
complete the transaction. The Mailbox receives this as an input.</li>
<li>The <code>L2TransactionRequestTwoBridgesOuter.l2GasPerPubdataByteLimit</code> is the maximum amount of gas per pubdata byte
that will be spent on L2 to complete the transaction. The Mailbox receives this as an input.</li>
<li>The <code>L2TransactionRequestTwoBridgesOuter.refundRecipient</code> is the address that will be refunded for the gas spent on
L2. The Mailbox receives this as an input.</li>
<li>The <code>L2TransactionRequestTwoBridgesOuter.secondBridgeAddress</code> is the address of the second bridge that will be
called. This is the arbitrary address that is called from the Bridgehub.</li>
<li>The <code>L2TransactionRequestTwoBridgesOuter.secondBridgeValue</code> is the amount of tokens that will be deposited on L2.
The second bridge receives this value as the baseToken (i.e. Eth on L1).</li>
<li>The <code>L2TransactionRequestTwoBridgesOuter.secondBridgeCalldata</code> is the calldata that will be passed to the second
bridge. This is the arbitrary calldata that is passed from the Bridgehub to the second bridge.</li>
<li>The secondBridge returns the <code>L2TransactionRequestTwoBridgesInner</code> struct to the Bridgehub. This is also passed to
the Mailbox as input. This is where the destination contract, calldata, factoryDeps are determined on the L2.</li>
</ul>
<p>This setup allows the user to bridge the baseToken of the origin chain A to a chain B with some other baseToken, by
specifying the A’s token in the secondBridgeValue, which will be minted on the destination chain as an ERC20 token,
and specifying the amount of B’s token in the mintValue, which will be minted as the baseToken and used to cover the
gas costs.</p>
</li>
</ul>
<h4 id="main-asset-shared-bridges-l2transactionrequesttwobridgesinner"><a class="header" href="#main-asset-shared-bridges-l2transactionrequesttwobridgesinner">Main asset shared bridges L2TransactionRequestTwoBridgesInner</a></h4>
<ul>
<li>
<p>Some assets have to be natively supported (ETH, WETH) and it also makes sense to support some generally accepted token
standards (ERC20 tokens), as this makes it easy to bridge those tokens (and ensures a single version of them exists on
the ZK Chain ecosystem). These canonical asset contracts are deployed from L1 by a bridge shared by all ZK Chains.
This is where assets are locked on L1. These bridges use the BridgeHub to communicate with all ZK Chains. Currently,
these bridges are the <code>WETH</code> and <code>ERC20</code> bridges.</p>
<ul>
<li>The pair on L2 is deployed from L1. The hash of the factory dependencies is stored on L1, and when a ZK Chain wants
to register, it can passes it in for deployment, it is verified, and the contract is deployed on L2. The actual
token contracts on L2 are deployed by the L2 bridge.</li>
</ul>
<pre><code>function initializeChain(
        uint256 _chainId,
        bytes[] calldata _factoryDeps,
        uint256 _deployBridgeImplementationFee,
        uint256 _deployBridgeProxyFee
    ) external payable {
    ....
    // Deploy L2 bridge proxy contract
        l2Bridge[_chainId] = BridgeInitializationHelper.requestDeployTransaction(
            _chainId,
            bridgehead,
            _deployBridgeProxyFee,
            l2SharedBridgeProxyBytecodeHash,
            l2SharedBridgeProxyConstructorData,
            // No factory deps are needed for L2 bridge proxy, because it is already passed in the previous step
            new bytes[](0)
        );
</code></pre>
</li>
</ul>
<h4 id="chain-type-manager"><a class="header" href="#chain-type-manager">Chain Type Manager</a></h4>
<ul>
<li><code>ChainTypeManager</code> A chain type manager manages proof verification and DA for multiple chains. It also implements the
following functionalities:
<ul>
<li><code>ChainTypeRegistry</code> The ST is shared for multiple chains, so initialization and upgrades have to be the same for all
chains. Registration is not permissionless but happens based on the registrations in the bridgehub’s <code>Registry</code>. At
registration a <code>DiamondProxy</code> is deployed and initialized with the appropriate <code>Facets</code> for each ZK Chain.</li>
<li><code>Facets</code> and <code>Verifier</code> are shared across chains that relies on the same ST: <code>Base</code>, <code>Executor</code> , <code>Getters</code>, <code>Admin</code>
, <code>Mailbox.</code>The <code>Verifier</code> is the contract that actually verifies the proof, and is called by the <code>Executor</code>.</li>
<li>Upgrade Mechanism The system requires all chains to be up-to-date with the latest implementation, so whenever an
update is needed, we have to “force” each chain to update, but due to decentralization, we have to give each chain a
time frame. This is done in the update mechanism contract, this is where the bootloader and system contracts are
published, and the <code>ProposedUpgrade</code> is stored. Then each chain can call this upgrade for themselves as needed.
After the deadline is over, the not-updated chains are frozen, that is, cannot post new proofs. Frozen chains can
unfreeze by updating their proof system.</li>
</ul>
</li>
<li>Each chain has a <code>DiamondProxy</code>.
<ul>
<li>The <a href="https://eips.ethereum.org/EIPS/eip-2535">Diamond Proxy</a> is the proxy pattern that is used for the chain
contracts. A diamond proxy points to multiple implementation contracts called facets. Each selector is saved in the
proxy, and the correct facet is selected and called.</li>
<li>In the future the DiamondProxy can be configured by picking alternative facets e.g. Validiums will have their own
<code>Executor</code></li>
</ul>
</li>
</ul>
<h4 id="chain-specific-contracts"><a class="header" href="#chain-specific-contracts">Chain specific contracts</a></h4>
<ul>
<li>A chain might implement its own specific consensus mechanism. This needs its own contracts. Only this contract will be
able to submit proofs to the State Transition contract.</li>
<li>DA contracts.</li>
<li>Currently, the <code>ValidatorTimelock</code> is an example of such a contract.</li>
</ul>
<h3 id="components-interactions"><a class="header" href="#components-interactions">Components interactions</a></h3>
<p>In this section, we will present some diagrams showing the interaction of different components.</p>
<h4 id="new-chain"><a class="header" href="#new-chain">New Chain</a></h4>
<p>A chain registers in the Bridgehub, this is where the chain ID is determined. The chain’s governor specifies the State
Transition that they plan to use. In the first version only a single State Transition contract will be available for
use, our with Boojum proof verification.</p>
<p>At initialization we prepare the <code>ZkSyncHyperchain</code> contract. We store the genesis batch hash in the ST contract, all
chains start out with the same state. A diamond proxy is deployed and initialised with this initial value, along with
predefined facets which are made available by the ST contract. These facets contain the proof verification and other
features required to process proofs. The chain ID is set in the VM in a special system transaction sent from L1.</p>
<!--![newChain.png](./img/newChain.png) Image outdated-->
<hr />
<h3 id="common-standards-and-upgrades"><a class="header" href="#common-standards-and-upgrades">Common Standards and Upgrades</a></h3>
<p>In this initial phase, ZK Chains have to follow some common standards, so that they can trust each other. This means all
chains start out with the same empty state, they have the same VM implementations and proof systems, asset contracts can
trust each on different chains, and the chains are upgraded together. We elaborate on the shared upgrade mechanism here.</p>
<h4 id="upgrade-mechanism"><a class="header" href="#upgrade-mechanism">Upgrade mechanism</a></h4>
<p>Currently, there are three types of upgrades for zkEVM. Normal upgrades (used for new features) are initiated by the
Governor (a multisig) and are public for a certain timeframe before they can be applied. Shadow upgrades are similar to
normal upgrades, but the data is not known at the moment the upgrade is proposed, but only when executed (they can be
executed with the delay, or instantly if approved by the security council). Instant upgrades (used for security issues),
on the other hand happen quickly and need to be approved by the Security Council in addition to the Governor. For ZK
Chains the difference is that upgrades now happen on multiple chains. This is only a problem for shadow upgrades - in
this case, the chains have to tightly coordinate to make all the upgrades happen in a short time frame, as the content
of the upgrade becomes public once the first chain is upgraded. The actual upgrade process is as follows:</p>
<ol>
<li>Prepare Upgrade for all chains:
<ul>
<li>The new facets and upgrade contracts have to be deployed,</li>
<li>The upgrade’ calldata (diamondCut, initCalldata with ProposedUpgrade) is hashed on L1 and the hash is saved.</li>
</ul>
</li>
<li>Upgrade specific chain
<ul>
<li>The upgrade has to be called on the specific chain. The upgrade calldata is passed in as calldata and verified. The
protocol version is updated.</li>
<li>Ideally, the upgrade will be very similar for all chains. If it is not, a smart contract can calculate the
differences. If this is also not possible, we have to set the <code>diamondCut</code> for each chain by hand.</li>
</ul>
</li>
<li>Freeze not upgraded chains
<ul>
<li>After a certain time the chains that are not upgraded are frozen.</li>
</ul>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../specs/zk_chains/interop.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../specs/zk_evm/vm_overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../specs/zk_chains/interop.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../specs/zk_evm/vm_overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../js/version-box.js"></script>
        <script src="../../js/mermaid-init.js"></script>


    </div>
    </body>
</html>
